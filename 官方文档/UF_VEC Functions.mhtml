From: <Saved by Blink>
Snapshot-Content-Location: https://docs.sw.siemens.com/documentation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/global.html#UF_VEC2_add
Subject: UF_VEC Functions
Date: Mon, 9 Jun 2025 13:29:38 +0800
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--hilTfECGzfblg3Rc6bmhAOa4CMWAow6sJwGYp9QSnX----"


------MultipartBoundary--hilTfECGzfblg3Rc6bmhAOa4CMWAow6sJwGYp9QSnX----
Content-Type: text/html
Content-ID: <frame-9FFCF4B4CE8F1A7714FB9D1D19AA5A0F@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: https://docs.sw.siemens.com/documentation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/global.html#UF_VEC2_add

<html><!-- Copyright 2007 UGS --><head><meta http-equiv=3D"Content-Type" co=
ntent=3D"text/html; charset=3Dwindows-1252"><link rel=3D"stylesheet" type=
=3D"text/css" href=3D"cid:css-306094f0-ac98-4937-be23-8d4bb25bf12e@mhtml.bl=
ink" /><link rel=3D"stylesheet" type=3D"text/css" href=3D"cid:css-816616fe-=
c05f-4a3b-9bb4-4265144277a5@mhtml.blink" /><link rel=3D"stylesheet" type=3D=
"text/css" href=3D"cid:css-1fecf193-a7d5-4911-8c29-84e6afa8f14e@mhtml.blink=
" />
    <link rel=3D"stylesheet" type=3D"text/css" href=3D"https://docs.sw.siem=
ens.com/documentation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en=
_US/ugopen_doc/ugopen.css">
    <title>UF_VEC Functions</title>
</head>
<body>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_add"></a>UF_VEC2_add=
</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL201=
90529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#UF=
_VEC2_add">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Performs a two dimensional vector addition and returns the v=
ector
<br>sum in vec_sum[2].
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_add<br>(<br><div class=3D"in=
dent">const double vec1 [ 2 ] , <br>const double vec2 [ 2 ] , <br>double ve=
c_sum [ 2 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector #1<=
/td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector #2</td></t=
r>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_sum [ =
2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">The vector sum of v=
ectors one and two <br> vec_sum =3D vec1 + vec2</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_affine_comb"></a>UF_=
VEC2_affine_comb</span> <a href=3D"https://docs.sw.siemens.com/documentatio=
n/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_ve=
c/uf_vec.html#UF_VEC2_affine_comb">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Performs a vector affine combination which consists of addin=
g an
<br>unscaled vector to a scaled vector. The first vector you input is vec[2=
],
<br>which is unscaled. The second vector you input is the vec_to_scale[2],
<br>which is scaled by the input argument scale. The resultant vector is
<br>output to vec_comb[2].
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">Void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_affine_comb<br>(<br><div cla=
ss=3D"indent">const double vec [ 2 ] , <br>double scale, <br>const double v=
ec_to_scale [ 2 ] , <br>double vec_comb [ 2 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Unscaled ve=
ctor</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">scale</td>=
<td id=3D"proto3">Input</td><td id=3D"proto4">Scale to apply to vec_to_scal=
e[2]</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec_=
to_scale [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">The secon=
d two dimensional vector which is scaled.</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_comb [=
 2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Vector sum of unsc=
aled vector and scaled vector <br> where vec_comb =3D vec + (scale vec_to_s=
cale)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_ask_perpendicular"><=
/a>UF_VEC2_ask_perpendicular</span> <a href=3D"https://docs.sw.siemens.com/=
documentation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugop=
en_doc/uf_vec/uf_vec.html#UF_VEC2_ask_perpendicular">(view source)</a><br>&=
nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Returns a 2D vector that is perpendicular to the input vecto=
r
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_ask_perpendicular<br>(<br><d=
iv class=3D"indent">const double vec1 [ 2 ] , <br>double vec_perp [ 2 ]  <b=
r></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">2D vector<=
/td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_perp [=
 2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">2D vector</td></tr=
>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_components"></a>UF_V=
EC2_components</span> <a href=3D"https://docs.sw.siemens.com/documentation/=
external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/=
uf_vec.html#UF_VEC2_components">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the scale factors of a linear combination of two =
vectors that
<br>form a third vector. The vector combination is equal to the sum of the
<br>two scaled vectors ( i.e., vec_comb =3D scale1  vec1 + scale2 + vec2).
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">0 =3D Scale factors can be calculated
<br>         1 =3D Input vectors are parallel
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">int UF_VEC2_components<br>(<br><div class=
=3D"indent">const double vec1 [ 2 ] , <br>const double vec2 [ 2 ] , <br>con=
st double vec_comb [ 2 ] , <br>double tolerance, <br>double * scale1, <br>d=
ouble * scale2 <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">First vect=
or of linear combination</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Second vector of =
linear combination</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec_=
comb [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Linear combin=
ation of vec1 and vec2</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking whether vec1 <br> and vec2 are parallel</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">scale1</=
td><td id=3D"proto3">Output</td><td id=3D"proto4">Scale factor of vec1 in l=
inear combination</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">scale2</=
td><td id=3D"proto3">Output</td><td id=3D"proto4">Scale factor of vec2 in l=
inear combination</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_convex_comb"></a>UF_=
VEC2_convex_comb</span> <a href=3D"https://docs.sw.siemens.com/documentatio=
n/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_ve=
c/uf_vec.html#UF_VEC2_convex_comb">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the position of a point between the two end point=
s of a line
<br>segment. The point on the line segment is defined by:
<br>pnt_on_seg =3D (parameter  pnt1) + ((1.0 - parameter)  pnt2).
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">Void.
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_convex_comb<br>(<br><div cla=
ss=3D"indent">double parameter, <br>const double pnt1 [ 2 ] , <br>const dou=
ble pnt2 [ 2 ] , <br>double pnt_on_seg [ 2 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">par=
ameter</td><td id=3D"proto3">Input</td><td id=3D"proto4">Parameter of point=
 to calculate</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">pnt1=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">First end point o=
f line segment</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">pnt2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Second end point =
of line segment</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">pnt_on_seg=
 [ 2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Point on line se=
gment</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_copy"></a>UF_VEC2_co=
py</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL2=
0190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#=
UF_VEC2_copy">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Copies the vector coordinates from a source vector to a dest=
ination
<br>vector (vec_dst =3D vec_src).
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_copy<br>(<br><div class=3D"i=
ndent">const double vec_src [ 2 ] , <br>double vec_dst [ 2 ]  <br></div>)<b=
r></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_src [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Source =
vector</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_dst [ =
2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Destination vector<=
/td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_cross"></a>UF_VEC2_c=
ross</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/P=
L20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.htm=
l#UF_VEC2_cross">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the cross product of two vectors.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_cross<br>(<br><div class=3D"=
indent">const double vec1 [ 2 ] , <br>const double vec2 [ 2 ] , <br>double =
* cross_product <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 1</=
td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 2</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">cross_pr=
oduct</td><td id=3D"proto3">Output</td><td id=3D"proto4">The cross product =
of vec1 and vec2 <br> cross_product =3D vec1 x vec2</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_distance"></a>UF_VEC=
2_distance</span> <a href=3D"https://docs.sw.siemens.com/documentation/exte=
rnal/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_v=
ec.html#UF_VEC2_distance">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the distance between two points.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_distance<br>(<br><div class=
=3D"indent">const double pnt1 [ 2 ] , <br>const double pnt2 [ 2 ] , <br>dou=
ble * distance <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">pnt1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Point 1</t=
d></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">pnt2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Point 2</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">distance=
</td><td id=3D"proto3">Output</td><td id=3D"proto4">The distance between pn=
t1 and pnt2 <br> (distance =3D ||pnt1 - pnt2||)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_dot"></a>UF_VEC2_dot=
</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL201=
90529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#UF=
_VEC2_dot">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the dot product of vec1 and vec2.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_dot<br>(<br><div class=3D"in=
dent">const double vec1 [ 2 ] , <br>const double vec2 [ 2 ] , <br>double * =
dot_product <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 1</=
td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 2</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">dot_prod=
uct</td><td id=3D"proto3">Output</td><td id=3D"proto4">The dot product of v=
ec1 and vec2 <br> dot_product =3D vec1 (dot) vec2</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_is_equal"></a>UF_VEC=
2_is_equal</span> <a href=3D"https://docs.sw.siemens.com/documentation/exte=
rnal/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_v=
ec.html#UF_VEC2_is_equal">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determines if two vectors are equal within the specified tol=
erance.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_is_equal<br>(<br><div class=
=3D"indent">const double vec1 [ 2 ] , <br>const double vec2 [ 2 ] , <br>dou=
ble tolerance, <br>int * is_equal <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 1</=
td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 2</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_equal</t=
d><td id=3D"proto3">Output</td><td id=3D"proto4">0 =3D Vectors are not equa=
l <br> 1 =3D Vectors are equal</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_is_parallel"></a>UF_=
VEC2_is_parallel</span> <a href=3D"https://docs.sw.siemens.com/documentatio=
n/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_ve=
c/uf_vec.html#UF_VEC2_is_parallel">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determine if vectors are parallel within an input tolerance.=
  If the sine of
<br>the angle between vec1 and vec2 is 0 then TRUE is returned.  Otherwise =
FALSE
<br>is returned.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_is_parallel<br>(<br><div cla=
ss=3D"indent">const double vec1 [ 2 ] , <br>const double vec2 [ 2 ] , <br>d=
ouble tolerance, <br>int * is_parallel <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">2D vector<=
/td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">2D vector</td></t=
r>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">tolerance</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_parallel=
</td><td id=3D"proto3">Output</td><td id=3D"proto4">=3D 0 Vectors are not p=
arallel <br> =3D 1 Vectors are parallel</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_is_perpendicular"></=
a>UF_VEC2_is_perpendicular</span> <a href=3D"https://docs.sw.siemens.com/do=
cumentation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen=
_doc/uf_vec/uf_vec.html#UF_VEC2_is_perpendicular">(view source)</a><br>&nbs=
p;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determine if vectors are perpendicular within an input toler=
ance.  If the cosine
<br>of the angle between vec1 and vec2 is 0 then TRUE is returned.  Otherwi=
se FALSE
<br>is returned.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_is_perpendicular<br>(<br><di=
v class=3D"indent">const double vec1 [ 2 ] , <br>const double vec2 [ 2 ] , =
<br>double tolerance, <br>int * is_perp <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">2D vector<=
/td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">2D vector</td></t=
r>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">tolerance</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_perp</td=
><td id=3D"proto3">Output</td><td id=3D"proto4">=3D 0 Vectors are not perpe=
ndicular <br> =3D 1 Vectors are perpendicular</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_is_zero"></a>UF_VEC2=
_is_zero</span> <a href=3D"https://docs.sw.siemens.com/documentation/extern=
al/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec=
.html#UF_VEC2_is_zero">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determines if a vector is zero within the specified toleranc=
e.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_is_zero<br>(<br><div class=
=3D"indent">const double vec [ 2 ] , <br>double tolerance, <br>int * is_zer=
o <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to t=
est</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_zero</td=
><td id=3D"proto3">Output</td><td id=3D"proto4">0 =3D Vectors is not zero <=
br> 1 =3D Vectors is zero</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_linear_comb"></a>UF_=
VEC2_linear_comb</span> <a href=3D"https://docs.sw.siemens.com/documentatio=
n/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_ve=
c/uf_vec.html#UF_VEC2_linear_comb">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the vector linear combination of two vectors with=
 the
<br>specified scale values.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_linear_comb<br>(<br><div cla=
ss=3D"indent">double scale1, <br>const double vec1 [ 2 ] , <br>double scale=
2, <br>const double vec2 [ 2 ] , <br>double vec_comb [ 2 ]  <br></div>)<br>=
</div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">sca=
le1</td><td id=3D"proto3">Input</td><td id=3D"proto4">Scale value for vecto=
r 1</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec1=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 1</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">scale2</td=
><td id=3D"proto3">Input</td><td id=3D"proto4">scale for vector 2</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 2</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_comb [=
 2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Vector linear comb=
ination <br> vec_comb =3D (scale vec1) + (scale2 vec2)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_mag"></a>UF_VEC2_mag=
</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL201=
90529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#UF=
_VEC2_mag">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the magnitude of a vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_mag<br>(<br><div class=3D"in=
dent">const double vec [ 2 ] , <br>double * magnitude <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector whos=
e magnitude is required</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">magnitud=
e</td><td id=3D"proto3">Output</td><td id=3D"proto4">Magnitude of vector <b=
r> magnitude =3D ||vec||</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_midpt"></a>UF_VEC2_m=
idpt</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/P=
L20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.htm=
l#UF_VEC2_midpt">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the coordinates of the mid-point on a line segmen=
t.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_midpt<br>(<br><div class=3D"=
indent">const double pnt1 [ 2 ] , <br>const double pnt2 [ 2 ] , <br>double =
mid_pnt [ 2 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">pnt1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">End Point =
#1 of line segment</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">pnt2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">End Point #2 of l=
ine segment</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">mid_pnt [ =
2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Mid-point of line s=
egment <br> mid_pnt =3D (0.5 pnt1) + (0.5 pnt2)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_negate"></a>UF_VEC2_=
negate</span> <a href=3D"https://docs.sw.siemens.com/documentation/external=
/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.h=
tml#UF_VEC2_negate">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the negative of a vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_negate<br>(<br><div class=3D=
"indent">const double vec [ 2 ] , <br>double negated_vec [ 2 ]  <br></div>)=
<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to n=
egate</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">negated_ve=
c [ 2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Negated vector =
<br> negated_vec =3D (-1.0) x vec</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_rotate"></a>UF_VEC2_=
rotate</span> <a href=3D"https://docs.sw.siemens.com/documentation/external=
/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.h=
tml#UF_VEC2_rotate">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Rotates a 2D vector about a line perpendicular to the plane =
of the
<br>vector through the vector origin.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_rotate<br>(<br><div class=3D=
"indent">const double vec [ 2 ] , <br>double angle, <br>double rotated_vec =
[ 2 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to r=
otate</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">angle</td>=
<td id=3D"proto3">Input</td><td id=3D"proto4">Angle to rotate through (in r=
adians)</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">rotated_ve=
c [ 2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Rotated vector<=
/td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_scale"></a>UF_VEC2_s=
cale</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/P=
L20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.htm=
l#UF_VEC2_scale">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Scales the coordinates of a vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_scale<br>(<br><div class=3D"=
indent">double scale, <br>const double vec [ 2 ] , <br>double scaled_vec [ =
2 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">sca=
le</td><td id=3D"proto3">Input</td><td id=3D"proto4">Scale factor</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec =
[ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to scale</t=
d></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">scaled_vec=
 [ 2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">scaled vector <b=
r> scaled_vec =3D (scale x vec)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_sub"></a>UF_VEC2_sub=
</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL201=
90529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#UF=
_VEC2_sub">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Subtracts one 2D vector from another.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_sub<br>(<br><div class=3D"in=
dent">const double vec1 [ 2 ] , <br>const double vec2 [ 2 ] , <br>double ve=
c_diff [ 2 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to =
subtract from</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to subtrac=
t</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_diff [=
 2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Vector difference =
<br> vec_diff =3D vec1 - vec2</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_unitize"></a>UF_VEC2=
_unitize</span> <a href=3D"https://docs.sw.siemens.com/documentation/extern=
al/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec=
.html#UF_VEC2_unitize">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Unitizes a 2D vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">0 =3D Success (unit vector can be calculated)
<br>         1 =3D input vector is zero
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">int UF_VEC2_unitize<br>(<br><div class=3D=
"indent">const double vec [ 2 ] , <br>double tolerance, <br>double * magnit=
ude, <br>double unit_vec [ 2 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to u=
nitize</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">magnitud=
e</td><td id=3D"proto3">Output</td><td id=3D"proto4">Vector magnitude =3D |=
vec|</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">unit_vec [=
 2 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Unitized vector =
=3D vec/|vec|</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC2_vec3"></a>UF_VEC2_ve=
c3</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL2=
0190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#=
UF_VEC2_vec3">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Converts a 2D vector to a 3D vector. Sets the Z-coordinate t=
o zero.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC2_vec3<br>(<br><div class=3D"i=
ndent">const double vec_2D [ 2 ] , <br>double vec_3D [ 3 ]  <br></div>)<br>=
</div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_2D [ 2 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">2D vecto=
r to convert to 3D</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_3D [ 3=
 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">3D vector</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_add"></a>UF_VEC3_add=
</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL201=
90529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#UF=
_VEC3_add">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Performs a three dimensional vector addition and returns the=
 vector
<br>sum in vec_sum[3].
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_add<br>(<br><div class=3D"in=
dent">const double vec1 [ 3 ] , <br>const double vec2 [ 3 ] , <br>double ve=
c_sum [ 3 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">The first =
three dimensional vector</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">The second three =
dimensional vector</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_sum [ =
3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">The vector sum of v=
ectors one and two <br> vec_sum =3D vec1 + vec2</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_affine_comb"></a>UF_=
VEC3_affine_comb</span> <a href=3D"https://docs.sw.siemens.com/documentatio=
n/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_ve=
c/uf_vec.html#UF_VEC3_affine_comb">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Performs a vector affine combination which consists of addin=
g an
<br>unscaled vector to a scaled vector. The first vector you input is vec[3=
],
<br>which is unscaled. The second vector you input is the vec_to_scale[3]
<br>which is scaled by the input argument scale. The resultant vector is
<br>output to vec_comb[3].
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_affine_comb<br>(<br><div cla=
ss=3D"indent">const double vec [ 3 ] , <br>double scale, <br>const double v=
ec_to_scale [ 3 ] , <br>double vec_comb [ 3 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Unscaled ve=
ctor</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">scale</td>=
<td id=3D"proto3">Input</td><td id=3D"proto4">Scale to apply to vec_to_scal=
e[3]</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec_=
to_scale [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">The secon=
d three dimensional vector which is scaled.</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_comb [=
 3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Vector sum of unsc=
aled vector and scaled vector <br> where vec_comb =3D vec + (scale vec_to_s=
cale)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_angle_between"></a>U=
F_VEC3_angle_between</span> <a href=3D"https://docs.sw.siemens.com/document=
ation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/u=
f_vec/uf_vec.html#UF_VEC3_angle_between">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the angle between two vectors using a third vecto=
r to
<br>determine the direction. The third vector is one that is perpendicular
<br>to both the vec_from and vec_to vectors. For example, if the two
<br>vectors lie in the x-y plane, then the third vector would be parallel t=
o
<br>the z-axis.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_angle_between<br>(<br><div c=
lass=3D"indent">const double vec_from [ 3 ] , <br>const double vec_to [ 3 ]=
 , <br>const double vec_ccw [ 3 ] , <br>double * angle <br></div>)<br></div=
>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_from [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector=
 to calculate angle from</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec_=
to [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to calcu=
late angle to</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec_=
ccw [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to defi=
ne counter-clockwise orientation</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">angle</t=
d><td id=3D"proto3">Output</td><td id=3D"proto4">Angle between vec_from and=
 vec_to using vec_ccw <br> to determine positive orientation. The angle is =
in <br> radians and 0.0 &lt;=3D (angle) &lt; 2 PI.</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_ask_perpendicular"><=
/a>UF_VEC3_ask_perpendicular</span> <a href=3D"https://docs.sw.siemens.com/=
documentation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugop=
en_doc/uf_vec/uf_vec.html#UF_VEC3_ask_perpendicular">(view source)</a><br>&=
nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Returns a 3D vector that is perpendicular to the input vecto=
r
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_ask_perpendicular<br>(<br><d=
iv class=3D"indent">const double vec1 [ 3 ] , <br>double vec_perp [ 3 ]  <b=
r></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">3D vector<=
/td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_perp [=
 3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">3D vector perpendi=
cular to the first <br> vector.</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_convex_comb"></a>UF_=
VEC3_convex_comb</span> <a href=3D"https://docs.sw.siemens.com/documentatio=
n/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_ve=
c/uf_vec.html#UF_VEC3_convex_comb">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the position of a point between the two end point=
s of a line
<br>segment. The point on the line segment is defined by:
<br>pnt_on_seg =3D (parameter  pnt1) + ((1.0 - parameter)  pnt2).
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_convex_comb<br>(<br><div cla=
ss=3D"indent">double parameter, <br>const double pnt1 [ 3 ] , <br>const dou=
ble pnt2 [ 3 ] , <br>double pnt_on_seg [ 3 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">par=
ameter</td><td id=3D"proto3">Input</td><td id=3D"proto4">Parameter of point=
 to calculate</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">pnt1=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">First end point o=
f line segment</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">pnt2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Second end point =
of line segment</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">pnt_on_seg=
 [ 3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Point on line se=
gment</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_copy"></a>UF_VEC3_co=
py</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL2=
0190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#=
UF_VEC3_copy">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Copies the vector coordinates from a source vector to a dest=
ination
<br>vector (vec_dst =3D vec_src).
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_copy<br>(<br><div class=3D"i=
ndent">const double vec_src [ 3 ] , <br>double vec_dst [ 3 ]  <br></div>)<b=
r></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_src [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Source =
vector</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_dst [ =
3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Destination vector<=
/td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_cross"></a>UF_VEC3_c=
ross</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/P=
L20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.htm=
l#UF_VEC3_cross">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the cross product of two vectors.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_cross<br>(<br><div class=3D"=
indent">const double vec1 [ 3 ] , <br>const double vec2 [ 3 ] , <br>double =
cross_product [ 3 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 1</=
td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 2</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">cross_prod=
uct [ 3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">The cross pro=
duct of vec1 and vec2 <br> cross_product =3D vec1 vec2</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_distance"></a>UF_VEC=
3_distance</span> <a href=3D"https://docs.sw.siemens.com/documentation/exte=
rnal/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_v=
ec.html#UF_VEC3_distance">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the distance between two points.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_distance<br>(<br><div class=
=3D"indent">const double pnt1 [ 3 ] , <br>const double pnt2 [ 3 ] , <br>dou=
ble * distance <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">pnt1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Point 1</t=
d></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">pnt2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Point 2</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">distance=
</td><td id=3D"proto3">Output</td><td id=3D"proto4">The distance between pn=
t1 and pnt2 <br> (distance =3D ||pnt1 - pnt2||)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_distance_to_plane"><=
/a>UF_VEC3_distance_to_plane</span> <a href=3D"https://docs.sw.siemens.com/=
documentation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugop=
en_doc/uf_vec/uf_vec.html#UF_VEC3_distance_to_plane">(view source)</a><br>&=
nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the normal distance from a point to a plane.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">0 =3D Success (distance can be calculated)
<br>         1 =3D The plane normal is zero
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">int UF_VEC3_distance_to_plane<br>(<br><di=
v class=3D"indent">const double pnt1 [ 3 ] , <br>const double pnt_on_plane =
[ 3 ] , <br>const double plane_normal [ 3 ] , <br>double tolerance, <br>dou=
ble * distance <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">pnt1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Point to c=
alculate distance from</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">pnt_=
on_plane [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Point loc=
ated on the plane</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">plan=
e_normal [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Plane nor=
mal</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">distance=
</td><td id=3D"proto3">Output</td><td id=3D"proto4">The normal distance fro=
m the point to the plane</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_dot"></a>UF_VEC3_dot=
</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL201=
90529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#UF=
_VEC3_dot">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the dot product of vec1 and vec2.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_dot<br>(<br><div class=3D"in=
dent">const double vec1 [ 3 ] , <br>const double vec2 [ 3 ] , <br>double * =
dot_product <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 1</=
td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 2</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">dot_prod=
uct</td><td id=3D"proto3">Output</td><td id=3D"proto4">The dot product of v=
ec1 and vec2 <br> dot_product =3D vec1 (dot) vec2</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_is_equal"></a>UF_VEC=
3_is_equal</span> <a href=3D"https://docs.sw.siemens.com/documentation/exte=
rnal/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_v=
ec.html#UF_VEC3_is_equal">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determines if two vectors are equal within the specified tol=
erance.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_is_equal<br>(<br><div class=
=3D"indent">const double vec1 [ 3 ] , <br>const double vec2 [ 3 ] , <br>dou=
ble tolerance, <br>int * is_equal <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 1</=
td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 2</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_equal</t=
d><td id=3D"proto3">Output</td><td id=3D"proto4">0 =3D Vectors are not equa=
l <br> 1 =3D Vectors are equal</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_is_parallel"></a>UF_=
VEC3_is_parallel</span> <a href=3D"https://docs.sw.siemens.com/documentatio=
n/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_ve=
c/uf_vec.html#UF_VEC3_is_parallel">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determine if vectors are parallel within an input tolerance.=
  If the sine of=20
<br>the angle between the vec1 and vec2 is less than tolerance then
<br>TRUE is returned.  Otherwise a FALSE will be returned.  To get an angle
<br>tolerance of x degrees the expected tolerance would be sin(xDEGRA).
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_is_parallel<br>(<br><div cla=
ss=3D"indent">const double vec1 [ 3 ] , <br>const double vec2 [ 3 ] , <br>d=
ouble tolerance, <br>int * is_parallel <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">3D vector<=
/td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">3D vector</td></t=
r>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">tolerance</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_parallel=
</td><td id=3D"proto3">Output</td><td id=3D"proto4">=3D 0 Vectors are not p=
arallel <br> =3D 1 Vectors are parallel</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_is_perpendicular"></=
a>UF_VEC3_is_perpendicular</span> <a href=3D"https://docs.sw.siemens.com/do=
cumentation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen=
_doc/uf_vec/uf_vec.html#UF_VEC3_is_perpendicular">(view source)</a><br>&nbs=
p;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determine if vectors are perpendicular an input tolerance.  =
If the cosine of the
<br>angle between vec1 and vec2 is less than the tolerance, then a TRUE is =
returned.
<br>Otherwise FALSE is returned.  To check perpendicularity with x degrees =
from 90,=20
<br>the expected tolerance would be cos( (90-x)DEGRA).
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_is_perpendicular<br>(<br><di=
v class=3D"indent">const double vec1 [ 3 ] , <br>const double vec2 [ 3 ] , =
<br>double tolerance, <br>int * is_perp <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">3D vector<=
/td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">3D vector</td></t=
r>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">tolerance</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_perp</td=
><td id=3D"proto3">Output</td><td id=3D"proto4">=3D 0 Vectors are not perpe=
ndicular <br> =3D 1 Vectors are perpendicular</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_is_zero"></a>UF_VEC3=
_is_zero</span> <a href=3D"https://docs.sw.siemens.com/documentation/extern=
al/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec=
.html#UF_VEC3_is_zero">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determines if a vector is zero within the specified toleranc=
e.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_is_zero<br>(<br><div class=
=3D"indent">const double vec [ 3 ] , <br>double tolerance, <br>int * is_zer=
o <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to t=
est</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_zero</td=
><td id=3D"proto3">Output</td><td id=3D"proto4">0 =3D Vectors is not zero <=
br> 1 =3D Vectors is zero</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_linear_comb"></a>UF_=
VEC3_linear_comb</span> <a href=3D"https://docs.sw.siemens.com/documentatio=
n/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_ve=
c/uf_vec.html#UF_VEC3_linear_comb">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the vector linear combination of two vectors with=
 the
<br>specified scale values.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_linear_comb<br>(<br><div cla=
ss=3D"indent">double scale1, <br>const double vec1 [ 3 ] , <br>double scale=
2, <br>const double vec2 [ 3 ] , <br>double vec_comb [ 3 ]  <br></div>)<br>=
</div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">sca=
le1</td><td id=3D"proto3">Input</td><td id=3D"proto4">Scale value for vecto=
r 1</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec1=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 1</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">scale2</td=
><td id=3D"proto3">Input</td><td id=3D"proto4">scale for vector 2</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector 2</td></tr=
>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_comb [=
 3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Vector linear comb=
ination <br> vec_comb =3D (scale vec1) + (scale2 vec2)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_mag"></a>UF_VEC3_mag=
</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL201=
90529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#UF=
_VEC3_mag">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the magnitude of a vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_mag<br>(<br><div class=3D"in=
dent">const double vec [ 3 ] , <br>double * magnitude <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector whos=
e magnitude is required</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">magnitud=
e</td><td id=3D"proto3">Output</td><td id=3D"proto4">Magnitude of vector <b=
r> magnitude =3D ||vec||</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_midpt"></a>UF_VEC3_m=
idpt</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/P=
L20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.htm=
l#UF_VEC3_midpt">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the coordinates of the mid-point on a line segmen=
t.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_midpt<br>(<br><div class=3D"=
indent">const double pnt1 [ 3 ] , <br>const double pnt2 [ 3 ] , <br>double =
mid_pnt [ 3 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">pnt1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">End Point =
#1 of line segment</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">pnt2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">End Point #2 of l=
ine segment</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">mid_pnt [ =
3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Mid-point of line s=
egment <br> mid_pnt =3D (0.5 pnt1) + (0.5 pnt2)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_negate"></a>UF_VEC3_=
negate</span> <a href=3D"https://docs.sw.siemens.com/documentation/external=
/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.h=
tml#UF_VEC3_negate">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the negative of a vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_negate<br>(<br><div class=3D=
"indent">const double vec [ 3 ] , <br>double negated_vec [ 3 ]  <br></div>)=
<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to n=
egate</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">negated_ve=
c [ 3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Negated vector =
<br> negated_vec =3D (-1.0) vec</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_scale"></a>UF_VEC3_s=
cale</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/P=
L20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.htm=
l#UF_VEC3_scale">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Scales the coordinates of a vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_scale<br>(<br><div class=3D"=
indent">double scale, <br>const double vec [ 3 ] , <br>double scaled_vec [ =
3 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">sca=
le</td><td id=3D"proto3">Input</td><td id=3D"proto4">Scale factor</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec =
[ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to scale</t=
d></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">scaled_vec=
 [ 3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">scaled vector <b=
r> scaled_vec =3D (scale x vec)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_sub"></a>UF_VEC3_sub=
</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL201=
90529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#UF=
_VEC3_sub">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Subtracts one vector from  another.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_sub<br>(<br><div class=3D"in=
dent">const double vec1 [ 3 ] , <br>const double vec2 [ 3 ] , <br>double ve=
c_diff [ 3 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to =
subtract from</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to subtrac=
t</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_diff [=
 3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Vector difference =
<br> vec_diff =3D vec1 - vec2</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_triple"></a>UF_VEC3_=
triple</span> <a href=3D"https://docs.sw.siemens.com/documentation/external=
/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.h=
tml#UF_VEC3_triple">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Calculates the triple scalar product of three vectors.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_triple<br>(<br><div class=3D=
"indent">const double vec1 [ 3 ] , <br>const double vec2 [ 3 ] , <br>const =
double vec3 [ 3 ] , <br>double * triple_product <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector #1<=
/td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector #2</td></t=
r>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec3=
 [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector #3</td></t=
r>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">triple_p=
roduct</td><td id=3D"proto3">Output</td><td id=3D"proto4">The triple scalar=
 product <br> triple_product =3D vec1 (dot) (vec2 x vec3)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_unitize"></a>UF_VEC3=
_unitize</span> <a href=3D"https://docs.sw.siemens.com/documentation/extern=
al/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec=
.html#UF_VEC3_unitize">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Unitizes a vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">0 =3D Success (unit vector can be calculated)
<br>         1 =3D input vector is zero
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">int UF_VEC3_unitize<br>(<br><div class=3D=
"indent">const double vec [ 3 ] , <br>double tolerance, <br>double * magnit=
ude, <br>double unit_vec [ 3 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to u=
nitize</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double *</td><td id=3D"proto2">magnitud=
e</td><td id=3D"proto3">Output</td><td id=3D"proto4">Vector magnitude =3D |=
|vec||</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">unit_vec [=
 3 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Unitized vector =
=3D vec/||vec||</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_vec2"></a>UF_VEC3_ve=
c2</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL2=
0190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#=
UF_VEC3_vec2">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Converts a 3D vector to a 2D vector. Strips the Z-coordinate=
 of the
<br>3D vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_vec2<br>(<br><div class=3D"i=
ndent">const double vec_3D [ 3 ] , <br>double vec_2D [ 2 ]  <br></div>)<br>=
</div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_3D [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">3D vecto=
r to convert to 2D</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_2D [ 2=
 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">2D vector</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_vec4"></a>UF_VEC3_ve=
c4</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL2=
0190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#=
UF_VEC3_vec4">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Converts a 3D vector to a 4D homogeneous vector with a weigh=
t of
<br>1.0.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_vec4<br>(<br><div class=3D"i=
ndent">const double vec_3D [ 3 ] , <br>double vec_4D [ 4 ]  <br></div>)<br>=
</div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_3D [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">3D vecto=
r to convert to 4D</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_4D [ 4=
 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">4D vector</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC3_vec4_homogen"></a>UF=
_VEC3_vec4_homogen</span> <a href=3D"https://docs.sw.siemens.com/documentat=
ion/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_=
vec/uf_vec.html#UF_VEC3_vec4_homogen">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Converts a 3D vector to a 4D homogeneous vector with the giv=
en
<br>weight. The 3D coordinates are multiplied by the specified weight. If
<br>the 3D coordinates are (x,y,z) and the weight =3D h, then the 4D
<br>coordinates would be (hx,hy,hz,h).
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC3_vec4_homogen<br>(<br><div cl=
ass=3D"indent">const double vec_3D [ 3 ] , <br>double weight, <br>double ve=
c_4D [ 4 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_3D [ 3 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">3D vecto=
r to convert</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">weight</td=
><td id=3D"proto3">Input</td><td id=3D"proto4">Weight to be used</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_4D [ 4=
 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">4D homogeneous vecto=
r</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC4_copy"></a>UF_VEC4_co=
py</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL2=
0190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#=
UF_VEC4_copy">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Copies the vector coordinates from a source vector to a dest=
ination
<br>vector (vec_dst =3D vec_src).
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC4_copy<br>(<br><div class=3D"i=
ndent">const double vec_src [ 4 ] , <br>double vec_dst [ 4 ]  <br></div>)<b=
r></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_src [ 4 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Source =
vector</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_dst [ =
4 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">Destination vector<=
/td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC4_is_equal"></a>UF_VEC=
4_is_equal</span> <a href=3D"https://docs.sw.siemens.com/documentation/exte=
rnal/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_v=
ec.html#UF_VEC4_is_equal">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determines if two vectors are equal within the specified tol=
erance.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC4_is_equal<br>(<br><div class=
=3D"indent">const double vec1 [ 4 ] , <br>const double vec2 [ 4 ] , <br>dou=
ble tolerance, <br>int * is_equal <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec1 [ 4 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector #1<=
/td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec2=
 [ 4 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector #2</td></t=
r>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_equal</t=
d><td id=3D"proto3">Output</td><td id=3D"proto4">0 =3D Vectors are not equa=
l <br> 1 =3D Vectors are equal</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC4_is_zero"></a>UF_VEC4=
_is_zero</span> <a href=3D"https://docs.sw.siemens.com/documentation/extern=
al/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec=
.html#UF_VEC4_is_zero">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Determines if a vector is zero within the specified toleranc=
e.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC4_is_zero<br>(<br><div class=
=3D"indent">const double vec [ 4 ] , <br>double tolerance, <br>int * is_zer=
o <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec [ 4 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to t=
est</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">tolerance<=
/td><td id=3D"proto3">Input</td><td id=3D"proto4">Tolerance value to use fo=
r checking</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> int *</td><td id=3D"proto2">is_zero</td=
><td id=3D"proto3">Output</td><td id=3D"proto4">0 =3D Vector is not zero <b=
r> 1 =3D Vector is zero</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC4_scale"></a>UF_VEC4_s=
cale</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/P=
L20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.htm=
l#UF_VEC4_scale">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Scales the coordinates of a vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC4_scale<br>(<br><div class=3D"=
indent">double scale, <br>const double vec [ 4 ] , <br>double scaled_vec [ =
4 ]  <br></div>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">sca=
le</td><td id=3D"proto3">Input</td><td id=3D"proto4">Scale factor</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto2">vec =
[ 4 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">Vector to scale</t=
d></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">scaled_vec=
 [ 4 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">scaled vector <b=
r> scaled_vec =3D (scale x vec)</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC4_vec3"></a>UF_VEC4_ve=
c3</span> <a href=3D"https://docs.sw.siemens.com/documentation/external/PL2=
0190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_vec/uf_vec.html#=
UF_VEC4_vec3">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Converts a 4D vector to a 3D vector by stripping the weight =
of the 4D
<br>vector.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC4_vec3<br>(<br><div class=3D"i=
ndent">const double vec_4D [ 4 ] , <br>double vec_3D [ 3 ]  <br></div>)<br>=
</div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_4D [ 4 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">4D vecto=
r to convert to 3D</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_3D [ 3=
 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">3D vector</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>
<span class=3D"title_function_name"><a name=3D"UF_VEC4_vec3_homogen"></a>UF=
_VEC4_vec3_homogen</span> <a href=3D"https://docs.sw.siemens.com/documentat=
ion/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/uf_=
vec/uf_vec.html#UF_VEC4_vec3_homogen">(view source)</a><br>&nbsp;<br>
<div class=3D"struct_aliases"><b>Defined in: uf_vec.h</b><br>&nbsp;<br></di=
v>
<div class=3D"title_function_overview">Overview<br></div><div class=3D"func=
tion_overview">Converts a 4D homogeneous vector to a 3D vector by dividing =
the 4D
<br>coordinates by the weight.
<br>
<br>
</div><div class=3D"title_function_overview">Return<br></div><div class=3D"=
function_overview">void.
<br>
<br>
</div><div class=3D"title_function_overview">Environment<br></div><div clas=
s=3D"function_overview">Internal  and  External
<br>&nbsp;<br>
</div><div class=3D"title_function_overview">Required License(s)<br></div><=
div class=3D"function_overview">gateway<br></div>
<br>&nbsp;<br>
<div class=3D"function_prototype">void UF_VEC4_vec3_homogen<br>(<br><div cl=
ass=3D"indent">const double vec_4D [ 4 ] , <br>double vec_3D [ 3 ]  <br></d=
iv>)<br></div>
<table cellpadding=3D"10" id=3D"proto">
<tbody><tr id=3D"proto"><td id=3D"proto1"> const double</td><td id=3D"proto=
2">vec_4D [ 4 ] </td><td id=3D"proto3">Input</td><td id=3D"proto4">4D vecto=
r to convert</td></tr>
<tr id=3D"proto"><td id=3D"proto1"> double</td><td id=3D"proto2">vec_3D [ 3=
 ] </td><td id=3D"proto3">Output</td><td id=3D"proto4">3D vector</td></tr>
</tbody></table>

<br>&nbsp;<br><hr><br>&nbsp;<br>

</body><div id=3D"immersive-translate-popup" style=3D"all: initial"><templa=
te shadowmode=3D"open"><div id=3D"mount" style=3D"display: block;"><div cla=
ss=3D"imt-fb-container right notranslate " dir=3D"ltr" style=3D"z-index: 21=
47483647; pointer-events: none; top: 850px; display: flex;"><div title=3D"&=
#20851;&#38381;&#24748;&#28014;&#29699;" class=3D"btn-animate" style=3D"tra=
nsform: translateX(100%); padding: 4px; cursor: pointer;"><svg width=3D"14"=
 height=3D"14" viewBox=3D"0 0 14 14" fill=3D"none" xmlns=3D"http://www.w3.o=
rg/2000/svg"><g clip-path=3D"url(#clip0_2589_9951)"><path d=3D"M7 14C5.1434=
8 14 3.36301 13.2625 2.05025 11.9497C0.737498 10.637 0 8.85652 0 7C0 5.1434=
8 0.737498 3.36301 2.05025 2.05025C3.36301 0.737498 5.14348 0 7 0C8.85652 0=
 10.637 0.737498 11.9497 2.05025C13.2625 3.36301 14 5.14348 14 7C14 8.85652=
 13.2625 10.637 11.9497 11.9497C10.637 13.2625 8.85652 14 7 14ZM4.183 5.064=
L6.118 7L4.183 8.936C4.12409 8.99361 4.07719 9.06234 4.04502 9.1382C4.01285=
 9.21406 3.99605 9.29554 3.99559 9.37794C3.99513 9.46034 4.01101 9.54201 4.=
04234 9.61823C4.07366 9.69444 4.11978 9.76369 4.17805 9.82195C4.23631 9.880=
22 4.30556 9.92634 4.38177 9.95766C4.45799 9.98898 4.53966 10.0049 4.62206 =
10.0044C4.70446 10.004 4.78594 9.98715 4.8618 9.95498C4.93766 9.92281 5.006=
39 9.87591 5.064 9.817L7 7.882L8.936 9.817C9.05327 9.93168 9.21104 9.99548 =
9.37506 9.99457C9.53908 9.99365 9.69612 9.92809 9.8121 9.8121C9.92809 9.696=
12 9.99365 9.53908 9.99457 9.37506C9.99548 9.21104 9.93168 9.05327 9.817 8.=
936L7.882 7L9.817 5.064C9.87591 5.00639 9.92281 4.93766 9.95498 4.8618C9.98=
715 4.78594 10.004 4.70446 10.0044 4.62206C10.0049 4.53966 9.98898 4.45799 =
9.95766 4.38177C9.92634 4.30556 9.88022 4.23631 9.82195 4.17805C9.76369 4.1=
1978 9.69444 4.07366 9.61823 4.04234C9.54201 4.01101 9.46034 3.99513 9.3779=
4 3.99559C9.29554 3.99605 9.21406 4.01285 9.1382 4.04502C9.06234 4.07719 8.=
99361 4.12409 8.936 4.183L7 6.118L5.064 4.183C4.94673 4.06832 4.78896 4.004=
52 4.62494 4.00543C4.46092 4.00635 4.30388 4.07191 4.1879 4.1879C4.07191 4.=
30388 4.00635 4.46092 4.00543 4.62494C4.00452 4.78896 4.06832 4.94673 4.183=
 5.064Z" fill=3D"#B1B1B1" fill-opacity=3D"0.32"></path></g><defs><clipPath =
id=3D"clip0_2589_9951"><rect width=3D"14" height=3D"14" fill=3D"white"></re=
ct></clipPath></defs></svg></div><div style=3D"position: relative; pointer-=
events: all; display: inline-block; opacity: 1;"><div><div class=3D"imt-fb-=
btn  right btn-animate " dir=3D"ltr" style=3D"transform: translateX(15px); =
opacity: 0.5;"><div><svg class=3D"imt-fb-logo-img imt-fb-logo-img-big-bg" x=
mlns=3D"http://www.w3.org/2000/svg" viewBox=3D"0 0 24 24" width=3D"20" heig=
ht=3D"20"><path fill=3D"none" d=3D"M0 0h24v24H0z"></path><path d=3D"M5 15v2=
a2 2 0 0 0 1.85 1.995L7 19h3v2H7a4 4 0 0 1-4-4v-2h2zm13-5l4.4 11h-2.155l-1.=
201-3h-4.09l-1.199 3h-2.154L16 10h2zm-1 2.885L15.753 16h2.492L17 12.885zM8 =
2v2h4v7H8v3H6v-3H2V4h4V2h2zm9 1a4 4 0 0 1 4 4v2h-2V7a2 2 0 0 0-2-2h-3V3h3zM=
6 6H4v3h2V6zm4 0H8v3h2V6z" fill=3D"rgba(255,255,255,1)"></path></svg></div>=
</div></div></div><div class=3D"imt-fb-more-buttons btn-animate" style=3D"m=
argin-top: 12px; transform: translateX(60px);"><div class=3D"btn-animate" s=
tyle=3D"position: relative; pointer-events: all; display: inline-block; opa=
city: 1;"><div><div class=3D"imt-fb-more-button"><svg width=3D"18" height=
=3D"18" viewBox=3D"0 0 18 18" fill=3D"none" xmlns=3D"http://www.w3.org/2000=
/svg"><path fill-rule=3D"evenodd" clip-rule=3D"evenodd" d=3D"M11.6861 1L15.=
2353 4.54635V7.11765V14.6471V15.5882C15.2353 15.9627 15.0866 16.3217 14.821=
8 16.5865C14.557 16.8513 14.198 17 13.8235 17H4.41176C4.03734 17 3.67825 16=
.8513 3.4135 16.5865C3.14874 16.3217 3 15.9627 3 15.5882V14.6471V7.11765V2.=
41176C3 2.03734 3.14874 1.67825 3.4135 1.4135C3.67825 1.14874 4.03734 1 4.4=
1176 1H11.6861ZM11.8692 3.17882V4.74212H13.4334L11.8692 3.17882ZM4.41171 15=
.5882V14.647V2.41176H10.4574L10.4578 6.15341H13.8235V14.647V15.5882H4.41171=
ZM12.7739 7.51746H5.46094V8.6155H12.7739V7.51746ZM5.46094 9.98805H12.7739V1=
1.0861H5.46094V9.98805ZM9.5127 12.36H5.46094V13.458H9.5127V12.36Z" fill=3D"=
#666666"></path></svg></div></div></div><div class=3D"btn-animate" style=3D=
"position: relative; pointer-events: all; display: inline-block; opacity: 1=
;"><div><div class=3D"imt-fb-more-button"><svg width=3D"18" height=3D"18" v=
iewBox=3D"0 0 18 18" fill=3D"none" xmlns=3D"http://www.w3.org/2000/svg"><pa=
th d=3D"M7.55741 1L10.0685 1.00329C10.8482 1.00471 11.4802 1.63624 11.4812 =
2.41647L11.4821 2.82588C11.9687 3.0278 12.4297 3.28671 12.8553 3.59718L13.1=
913 3.40329C13.516 3.21676 13.9013 3.1665 14.2629 3.26352C14.6246 3.36055 1=
4.933 3.59695 15.1207 3.92094L16.3795 6.09365C16.5601 6.40546 16.6149 6.774=
4 16.5328 7.12523C16.4507 7.47606 16.2378 7.78235 15.9376 7.98165L15.8609 8=
.02871L15.5235 8.22353C15.5819 8.76273 15.5736 9.30708 15.4986 9.84424L15.7=
372 9.98259C16.0496 10.1631 16.2812 10.4561 16.3848 10.8017C16.4884 11.1472=
 16.456 11.5193 16.2944 11.8419L16.2553 11.9153L15.076 13.9576C14.8955 14.2=
7 14.6025 14.5017 14.2569 14.6053C13.9113 14.7088 13.5392 14.6765 13.2167 1=
4.5148L13.1433 14.4753L12.8172 14.2871C12.4074 14.5817 11.9651 14.8283 11.4=
991 15.0221L11.4995 15.5831C11.5 15.9434 11.3629 16.2904 11.1163 16.5532C10=
.8697 16.816 10.5321 16.9748 10.1725 16.9972L10.0831 17L7.57153 16.9967C7.1=
9697 16.9961 6.83793 16.847 6.57312 16.5821C6.30831 16.3172 6.15932 15.9581=
 6.15883 15.5835L6.15788 14.9073C5.76852 14.7244 5.39771 14.5044 5.05059 14=
.2504L4.44918 14.5967C4.12448 14.7834 3.73902 14.8337 3.37726 14.7367C3.015=
51 14.6397 2.70698 14.4032 2.5193 14.0791L1.26047 11.9064C1.07996 11.5945 1=
.02522 11.2255 1.10742 10.8747C1.18962 10.5238 1.40257 10.2176 1.70283 10.0=
184L1.77906 9.97129L2.3913 9.61835C2.34424 9.17129 2.34188 8.71765 2.38706 =
8.26494L1.70753 7.87247C1.39506 7.69207 1.16331 7.39911 1.05965 7.05351C0.9=
55998 6.70791 0.988275 6.33577 1.14989 6.01318L1.18941 5.93976L2.36871 3.89=
741C2.54919 3.58502 2.84218 3.35337 3.18777 3.2498C3.53336 3.14624 3.90547 =
3.17859 4.228 3.34023L4.30141 3.37976L4.89436 3.72188C5.28027 3.42082 5.698=
54 3.1637 6.14141 2.95529L6.14047 2.41694C6.14001 2.05657 6.27707 1.7096 6.=
52367 1.44681C6.77028 1.18403 7.10786 1.02523 7.46753 1.00282L7.55741 1ZM7.=
55553 2.41506L7.55694 3.85271L6.74377 4.23576C6.39553 4.39906 6.06706 4.600=
94 5.764 4.83718L5.01247 5.424L3.62941 4.62494L3.59365 4.60518L2.41483 6.64=
753L3.88636 7.49694L3.79506 8.40612C3.75968 8.7598 3.76078 9.11619 3.79836 =
9.46965L3.8953 10.3854L2.48494 11.1976L3.7433 13.3704L5.14377 12.5647L5.886=
36 13.1087C6.15997 13.309 6.45231 13.4823 6.7593 13.6264L7.57106 14.008L7.5=
7388 15.5816L10.0845 15.5849L10.0831 14.0791L10.9555 13.7158C11.3216 13.563=
5 11.6689 13.3698 11.9908 13.1384L12.7329 12.6047L13.8506 13.2499L15.0289 1=
1.2075L13.9654 10.592L14.0972 9.64847C14.1561 9.22659 14.1628 8.79904 14.11=
69 8.37553L14.0181 7.45882L15.1555 6.80235L13.8967 4.62965L12.7645 5.28235L=
12.0214 4.74024C11.686 4.4956 11.3229 4.29152 10.9395 4.13224L10.0689 3.770=
82L10.0666 2.41835L7.55553 2.41506ZM10.3715 6.47624C11.0214 6.85201 11.4955=
 7.47036 11.6898 8.19547C11.8841 8.92058 11.7827 9.69316 11.4078 10.3435C11=
.2223 10.6654 10.9752 10.9476 10.6805 11.1739C10.3859 11.4002 10.0495 11.56=
62 9.69068 11.6623C9.33183 11.7585 8.95754 11.7829 8.58923 11.7343C8.22092 =
11.6856 7.86582 11.5648 7.54424 11.3788C6.89445 11.003 6.4204 10.3846 6.226=
2 9.65948C6.032 8.93438 6.13352 8.16184 6.50847 7.51153C6.69395 7.18963 6.9=
4107 6.90746 7.23571 6.68117C7.53034 6.45488 7.86671 6.28891 8.22556 6.1927=
5C8.58441 6.09659 8.9587 6.07213 9.32701 6.12077C9.69532 6.16942 10.0504 6.=
29021 10.372 6.47624H10.3715ZM7.73388 8.21835C7.54638 8.54388 7.49567 8.930=
5 7.5929 9.29336C7.69012 9.65623 7.92733 9.96571 8.25247 10.1539C8.41305 10=
.2468 8.59037 10.3071 8.77429 10.3314C8.9582 10.3557 9.14511 10.3435 9.3243=
1 10.2956C9.50351 10.2476 9.67149 10.1647 9.81864 10.0517C9.96579 9.93877 1=
0.0892 9.7979 10.1819 9.63718C10.5588 8.98353 10.356 8.15435 9.73435 7.7449=
4L9.66377 7.70118L9.59035 7.66165C9.26834 7.49988 8.89663 7.46742 8.55145 7=
.57093C8.20626 7.67444 7.91375 7.90608 7.73388 8.21835Z" fill=3D"#666666"><=
/path></svg></div></div></div></div></div></div></template></div></html>
------MultipartBoundary--hilTfECGzfblg3Rc6bmhAOa4CMWAow6sJwGYp9QSnX----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: https://docs.sw.siemens.com/documentation/external/PL20190529153442596/en-US/nx/11/nx_api_sc/en_US/ugopen_doc/ugopen.css

@charset "windows-1252";

body { font-size: 10pt; font-family: Arial, Helvetica, "sans-serif"; color:=
 rgb(0, 0, 0); background-color: rgb(255, 255, 255); margin: 10pt 15pt; }

ul { margin-top: 3pt; margin-bottom: 5pt; }

a:link { color: rgb(0, 0, 204); }

a:visited { color: rgb(0, 0, 204); }

a:active { color: rgb(0, 0, 204); }

a { text-decoration: none; }

a:hover, a.selected:hover { color: red; text-decoration: underline; }

.check { text-decoration: none; color: rgb(0, 0, 0); }

td { margin: 5pt; }

.code_source { font-size: 10pt; font-family: "Courier New", courier, "serif=
"; color: rgb(0, 0, 0); }

.code_comment, .code_green { color: green; }

.code_define, .code_blue { color: blue; }

.code_red { color: darkred; }

.code_typdef { color: purple; }

.search_blue { color: darkblue; }

.indent { margin-left: 15pt; margin-right: 15pt; }

.function_prototype { font-size: 11pt; font-family: Arial, Helvetica, "sans=
-serif"; color: darkblue; font-weight: bold; margin: 10pt 15pt; }

table#proto { margin-left: 0pt; margin-right: 0pt; border-collapse: collaps=
e; border: 4px solid rgb(192, 192, 192); }

tdsearch { font-size: 9pt; font-family: Arial, Helvetica, "sans-serif"; col=
or: rgb(0, 0, 0); }

td#proto1 { font-size: 10pt; font-family: Arial, Helvetica, "sans-serif"; c=
olor: rgb(0, 0, 0); vertical-align: top; border-top: 1px solid rgb(204, 204=
, 204); }

td#proto2 { font-size: 10pt; font-weight: bold; font-family: Arial, Helveti=
ca, "sans-serif"; color: rgb(0, 0, 0); vertical-align: top; border-top: 1px=
 solid rgb(204, 204, 204); }

td#proto3 { font-size: 9pt; font-family: Arial, Helvetica, "sans-serif"; co=
lor: rgb(0, 0, 0); vertical-align: top; border-top: 1px solid rgb(204, 204,=
 204); }

td#proto4 { font-size: 10pt; font-family: Arial, Helvetica, "sans-serif"; c=
olor: rgb(0, 0, 0); vertical-align: top; border-top: 1px solid rgb(192, 192=
, 192); }

.menu_title { font-size: 12pt; font-family: Arial, Helvetica, "sans-serif";=
 color: darkblue; font-weight: bold; }

.menu_links { font-size: 10pt; font-family: Arial, Helvetica, "sans-serif";=
 color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); margin: 3pt 5pt=
 10pt; }

.link_top { font-size: 10pt; }

.menu_back_title { font-size: 12pt; font-family: Arial, Helvetica, "sans-se=
rif"; color: darkblue; font-weight: bold; }

h1 { font-size: 22pt; font-family: Arial, Helvetica, "sans-serif"; color: d=
arkblue; font-weight: bold; margin-top: 10pt; margin-bottom: 5pt; }

h2 { font-size: 18pt; font-family: Arial, Helvetica, "sans-serif"; color: d=
arkblue; font-weight: bold; margin-top: 10pt; margin-bottom: 5pt; }

h3 { font-size: 14pt; font-family: Arial, Helvetica, "sans-serif"; color: d=
arkblue; font-weight: bold; margin-top: 10pt; margin-bottom: 5pt; }

h4 { font-size: 12pt; font-family: Arial, Helvetica, "sans-serif"; color: d=
arkblue; font-weight: bold; margin-top: 10pt; margin-bottom: 5pt; }

.title_struct_name, .title_function_name { font-size: 14pt; font-family: Ar=
ial, Helvetica, "sans-serif"; color: darkblue; font-weight: bold; }

.title_struct_overview, .title_function_overview { font-size: 12pt; font-fa=
mily: Arial, Helvetica, "sans-serif"; color: darkblue; font-weight: bold; m=
argin-left: 5pt; margin-right: 5pt; }

.struct_overview, .function_overview { font-size: 11pt; font-family: Arial,=
 Helvetica, "sans-serif"; color: rgb(0, 0, 0); margin-left: 15pt; margin-ri=
ght: 15pt; }

.and_or { font-size: 9pt; }

.struct_aliases { font-size: 10pt; font-family: Arial, Helvetica, "sans-ser=
if"; color: rgb(0, 0, 0); }

.title_struct_members { font-size: 12pt; font-family: Arial, Helvetica, "sa=
ns-serif"; color: darkblue; font-weight: bold; margin-left: 5pt; margin-rig=
ht: 5pt; }

.title_struct_member_name { font-size: 11pt; font-family: Arial, Helvetica,=
 "sans-serif"; color: darkblue; font-weight: bold; margin-left: 15pt; margi=
n-right: 15pt; }

.struct_member_type { font-size: 10pt; font-family: Arial, Helvetica, "sans=
-serif"; color: darkblue; margin-left: 25pt; margin-right: 25pt; }

.struct_member_comments { font-size: 10pt; font-family: Arial, Helvetica, "=
sans-serif"; color: rgb(0, 0, 0); margin-left: 25pt; margin-right: 25pt; }

table#withBorder { border-collapse: collapse; border: 4px solid rgb(192, 19=
2, 192); }

td#horizontalBorders { padding: 10pt; vertical-align: top; border-top: 1px =
solid rgb(204, 204, 204); }

td#verticalBorders { padding: 10pt; border-right: 1px solid rgb(204, 204, 2=
04); }

td#allBorders { padding: 10pt; font-size: 10pt; border-top: 1px solid rgb(2=
04, 204, 204); border-right: 1px solid rgb(204, 204, 204); }
------MultipartBoundary--hilTfECGzfblg3Rc6bmhAOa4CMWAow6sJwGYp9QSnX----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-1fecf193-a7d5-4911-8c29-84e6afa8f14e@mhtml.blink

@charset "windows-1252";

.immersive-translate-input { position: absolute; inset: 0px; z-index: 21474=
83647; display: flex; justify-content: center; align-items: center; }

.immersive-translate-attach-loading::after { content: " "; --loading-color:=
 #f78fb6; width: 6px; height: 6px; border-radius: 50%; display: block; marg=
in: 12px auto; color: white; box-sizing: border-box; animation: 1.5s linear=
 0s infinite normal none running immersiveTranslateShadowRolling; position:=
 absolute; top: 50%; left: 50%; transform: translate(-2000%, -50%); z-index=
: 100; }

.immersive-translate-loading-spinner { vertical-align: middle !important; w=
idth: 10px !important; height: 10px !important; display: inline-block !impo=
rtant; margin: 0px 4px !important; border-width: 2px !important; border-sty=
le: solid !important; border-color: rgba(0, 0, 0, 0.376) rgba(221, 244, 255=
, 0.6) rgba(221, 244, 255, 0.6) rgba(0, 0, 0, 0.376) !important; border-ima=
ge: initial !important; border-radius: 50% !important; padding: 0px !import=
ant; animation: 0.6s linear 0s infinite normal none running immersive-trans=
late-loading-animation !important; }

@-webkit-keyframes immersive-translate-loading-animation {=20
  0% { transform: rotate(0deg); }
  100% { transform: rotate(359deg); }
}

@keyframes immersive-translate-loading-animation {=20
  0% { transform: rotate(0deg); }
  100% { transform: rotate(359deg); }
}

.immersive-translate-input-loading { --loading-color: #f78fb6; width: 6px; =
height: 6px; border-radius: 50%; display: block; margin: 12px auto; positio=
n: relative; color: white; left: -100px; box-sizing: border-box; animation:=
 1.5s linear 0s infinite normal none running immersiveTranslateShadowRollin=
g; }

@keyframes immersiveTranslateShadowRolling {=20
  0% { box-shadow: rgba(255, 255, 255, 0) 0px 0px, rgba(255, 255, 255, 0) 0=
px 0px, rgba(255, 255, 255, 0) 0px 0px, rgba(255, 255, 255, 0) 0px 0px; }
  12% { box-shadow: 100px 0 var(--loading-color), 0px 0 rgba(255, 255, 255,=
 0),
      0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0); }
  25% { box-shadow: 110px 0 var(--loading-color), 100px 0 var(--loading-col=
or),
      0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0); }
  36% { box-shadow: 120px 0 var(--loading-color), 110px 0 var(--loading-col=
or),
      100px 0 var(--loading-color), 0px 0 rgba(255, 255, 255, 0); }
  50% { box-shadow: 130px 0 var(--loading-color), 120px 0 var(--loading-col=
or),
      110px 0 var(--loading-color), 100px 0 var(--loading-color); }
  62% { box-shadow: 200px 0 rgba(255, 255, 255, 0), 130px 0 var(--loading-c=
olor),
      120px 0 var(--loading-color), 110px 0 var(--loading-color); }
  75% { box-shadow: 200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, =
255, 0),
      130px 0 var(--loading-color), 120px 0 var(--loading-color); }
  87% { box-shadow: 200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, =
255, 0),
      200px 0 rgba(255, 255, 255, 0), 130px 0 var(--loading-color); }
  100% { box-shadow: rgba(255, 255, 255, 0) 200px 0px, rgba(255, 255, 255, =
0) 200px 0px, rgba(255, 255, 255, 0) 200px 0px, rgba(255, 255, 255, 0) 200p=
x 0px; }
}

.immersive-translate-toast { display: flex; position: fixed; z-index: 21474=
83647; left: 0px; right: 0px; top: 1%; width: fit-content; padding: 12px 20=
px; margin: auto; overflow: auto; background: rgb(254, 246, 249); box-shado=
w: rgba(0, 10, 30, 0.06) 0px 4px 10px 0px; font-size: 15px; border-radius: =
8px; color: rgb(51, 51, 51); }

.immersive-translate-toast-content { display: flex; flex-direction: row; al=
ign-items: center; }

.immersive-translate-toast-hidden { margin: 0px 20px 0px 72px; text-decorat=
ion: underline; cursor: pointer; }

.immersive-translate-toast-close { color: rgb(102, 102, 102); font-size: 20=
px; font-weight: bold; padding: 0px 10px; cursor: pointer; }

@media screen and (max-width: 768px) {
  .immersive-translate-toast { top: 0px; padding: 12px 0px 0px 10px; }
  .immersive-translate-toast-content { flex-direction: column; text-align: =
center; }
  .immersive-translate-toast-hidden { margin: 10px auto; }
}

.immersive-translate-modal { display: none; position: fixed; z-index: 21474=
83647; left: 0px; top: 0px; width: 100%; height: 100%; overflow: auto; back=
ground-color: rgba(0, 0, 0, 0.4); font-size: 15px; }

.immersive-translate-modal-content { background-color: rgb(254, 254, 254); =
margin: 10% auto; padding: 40px 24px 24px; border: 1px solid rgb(136, 136, =
136); border-radius: 10px; width: 80%; max-width: 270px; font-family: syste=
m-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sa=
ns-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto C=
olor Emoji"; position: relative; }

@media screen and (max-width: 768px) {
  .immersive-translate-modal-content { margin: 50% auto !important; }
}

.immersive-translate-modal .immersive-translate-modal-content-in-input { ma=
x-width: 500px; }

.immersive-translate-modal-content-in-input .immersive-translate-modal-body=
 { text-align: left; max-height: unset; }

.immersive-translate-modal-title { text-align: center; font-size: 16px; fon=
t-weight: 700; color: rgb(51, 51, 51); }

.immersive-translate-modal-body { text-align: center; font-size: 14px; font=
-weight: 400; color: rgb(51, 51, 51); word-break: break-all; margin-top: 24=
px; }

@media screen and (max-width: 768px) {
  .immersive-translate-modal-body { max-height: 250px; overflow-y: auto; }
}

.immersive-translate-close { color: rgb(102, 102, 102); position: absolute;=
 right: 16px; top: 16px; font-size: 20px; font-weight: bold; }

.immersive-translate-close:hover, .immersive-translate-close:focus { color:=
 black; text-decoration: none; cursor: pointer; }

.immersive-translate-modal-footer { display: flex; justify-content: center;=
 flex-wrap: wrap; margin-top: 24px; }

.immersive-translate-btn { width: fit-content; color: rgb(255, 255, 255); b=
ackground-color: rgb(234, 76, 137); border: none; font-size: 16px; margin: =
0px 8px; padding: 9px 30px; border-radius: 5px; display: flex; align-items:=
 center; justify-content: center; cursor: pointer; transition: background-c=
olor 0.3s; }

.immersive-translate-btn:hover { background-color: rgb(240, 130, 172); }

.immersive-translate-btn:disabled { opacity: 0.6; cursor: not-allowed; }

.immersive-translate-btn:disabled:hover { background-color: rgb(234, 76, 13=
7); }

.immersive-translate-cancel-btn { background-color: rgb(89, 107, 120); }

.immersive-translate-cancel-btn:hover { background-color: rgb(65, 84, 98); =
}

.immersive-translate-action-btn { background-color: transparent; color: rgb=
(234, 76, 137); border: 1px solid rgb(234, 76, 137); }

.immersive-translate-btn svg { margin-right: 5px; }

.immersive-translate-link { cursor: pointer; user-select: none; -webkit-use=
r-drag: none; text-decoration: none; color: rgb(0, 123, 255); -webkit-tap-h=
ighlight-color: rgba(0, 0, 0, 0.1); }

.immersive-translate-primary-link { cursor: pointer; user-select: none; -we=
bkit-user-drag: none; text-decoration: none; color: rgb(234, 76, 137); -web=
kit-tap-highlight-color: rgba(0, 0, 0, 0.1); }

.immersive-translate-modal input[type=3D"radio"] { margin: 0px 6px; cursor:=
 pointer; }

.immersive-translate-modal label { cursor: pointer; }

.immersive-translate-close-action { position: absolute; top: 2px; right: 0p=
x; cursor: pointer; }

.imt-image-status { background-color: rgba(0, 0, 0, 0.5) !important; displa=
y: flex !important; flex-direction: column !important; align-items: center =
!important; justify-content: center !important; border-radius: 16px !import=
ant; }

.imt-image-status img, .imt-image-status svg, .imt-img-loading { width: 28p=
x !important; height: 28px !important; margin: 0px 0px 8px !important; min-=
height: 28px !important; min-width: 28px !important; position: relative !im=
portant; }

.imt-img-loading { background-image: url("data:image/png;base64,iVBORw0KGgo=
AAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAAtFBMVEUAAAD///////////////////////////=
///////////////////////////////////////////////////////////////////////////=
///////////////////////////////////////////////////////////////////////////=
///////////////////////////////////////////////////////////oK74hAAAAPHRSTlM=
ABBMIDyQXHwyBfFdDMSw+OjXCb+5RG51IvV/k0rOqlGRM6KKMhdvNyZBz9MaupmxpWyj437iYd/=
yJVNZeuUC7AAACt0lEQVRIx53T2XKiUBCA4QYOiyCbiAsuuGBcYtxiYtT3f6/pbqoYHVFO5r+ii=
vpo6DpAWYpqeoFfr9f90DsYAuRSWkFnPO50OgR9PwiCUFcl2GEcx+N/YBh6pvKaefHlUgZd1zVe=
0NbYcQjGBfzrPE8Xz8aF+71D8gG6DHFPpc4a7xFiCDuhaWgKgGIJQ3d5IMGDrpS4S5KgpIm+en9=
f6PlAhKby4JwEIxlYJV9h5k5nee9GoxHJ2IDSNB0dwdad1NAxDJ/uXDHYmebdk4PdbkS58CIVHd=
YSUHTYYRWOJblWSyu2lmy3KNFVJNBhxcuGW4YBVCbYGRZwIooipHsNqjM4FbgOQqQqSKQQU9V8x=
mi1QlgHqQQ6DDBvRUVCDirs+EzGDGOQTCATgtYTnbCVLgsVgRE0T1QE0qHCFAht2z6dLvJQs3Lo=
2FQoDxWNUiBhaP4eRgwNkI+dAjVOA/kUrIDwf3CG8NfNOE0eiFotSuo+rBiq8tD9oY4Qzc6YJw9=
9hl1wzpQvD7ef2M8QgnOGJfJw+EltQc+oX2yn907QB22WZcvlUpd143dqQu+8pCJZuGE4xCuPXJ=
qqcs5sNpsI93Rmzym1k4Npk+oD1SH3/a3LOK/JpUBpWfqNySxWzCfNCUITuDG5dtuphrUJ1myeI=
E9bIsPiKrfqTai5WZxbhtNphYx6GEIHihyGFTI69lje/rxajdh0s0msZ0zYxyPLhYCb1CyHm9Qs=
d2H37Y3lugVwL9kNh8Ot8cha6fUNQ8nuXi5z9/ExsAO4zQrb/ev1yrCB7lGyQzgYDGuxq1toDN/=
JGvN+HyWNHKB7zEoK+PX11e12G431erGYzwmytAWU56fkMHY5JJnDRR2eZji3AwtIcrEV8Cojat=
/BdQ7XOwGV1e1hDjGGjXbdArm8uJZtCH5MbcctVX8A1WpqumJHwckAAAAASUVORK5CYII=3D");=
 background-size: 28px 28px; animation: 1s linear 0s infinite normal none r=
unning image-loading-rotate !important; }

.imt-image-status span { color: var(--bg-2, #fff) !important; font-size: 14=
px !important; line-height: 14px !important; font-weight: 500 !important; f=
ont-family: "PingFang SC", Arial, sans-serif !important; }

@keyframes image-loading-rotate {=20
  0% { transform: rotate(360deg); }
  100% { transform: rotate(0deg); }
}
------MultipartBoundary--hilTfECGzfblg3Rc6bmhAOa4CMWAow6sJwGYp9QSnX----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-816616fe-c05f-4a3b-9bb4-4265144277a5@mhtml.blink

@charset "windows-1252";

.gwd-row[data-v-07d1070f] { display: flex; flex-direction: row; }

.gwd-inline-row[data-v-07d1070f] { display: inline-flex; flex-direction: ro=
w; }

.gwd-column[data-v-07d1070f] { display: flex; flex-direction: column; }

.gwd-inline-column[data-v-07d1070f] { display: inline-flex; flex-direction:=
 column; }

.gwd-align[data-v-07d1070f] { align-content: center; align-items: center; }

.gwd-jcc[data-v-07d1070f] { justify-content: center; }

.gwd-jic[data-v-07d1070f] { justify-items: center; }

.gwd-button[data-v-07d1070f] { outline: none; border: none; }

.bjg-bar-button[data-v-07d1070f] { font-size: 0px; }

.bjg-hover-bg[data-v-07d1070f] { background: rgb(255, 251, 239); }

.bjg-bar-button[data-v-07d1070f]:hover { background: rgb(255, 251, 239); cu=
rsor: pointer; }

.bjg-bar-button:hover .bjg-window[data-v-07d1070f] { display: block; }

.mainbar-fold .bjg-bar-button[data-v-07d1070f], .mainbar-fold #top_coupon_b=
tn[data-v-07d1070f], .mainbar-fold .rinfo-btn[data-v-07d1070f], .mainbar-fo=
ld .gwd-bottom-tmall[data-v-07d1070f] { display: none !important; }

.gwd-font12[data-v-07d1070f] { font-size: 12px; }

.gwd-font14[data-v-07d1070f] { font-size: 14px; }

.gwd-red[data-v-07d1070f] { color: rgb(255, 53, 50); }

.gwd-red-bg[data-v-07d1070f] { background: rgb(255, 53, 50); }

.gwd-hui333[data-v-07d1070f] { color: rgb(51, 51, 51); }

.gwd-hui999[data-v-07d1070f] { color: rgb(153, 153, 153); }

.gwd-font10[data-v-07d1070f] { font-size: 12px; transform: scale(0.8333); t=
ransform-origin: center bottom; }

.gwd-font11[data-v-07d1070f] { font-size: 12px; transform: scale(0.91666); =
transform-origin: center bottom; }

.gwd-font9[data-v-07d1070f] { font-size: 12px; transform: scale(0.75); tran=
sform-origin: center bottom; }

.gwd-hoverable[data-v-07d1070f]:hover { background: rgb(237, 241, 242); }

.right-info > [data-v-07d1070f] { border-left: 1px solid rgb(237, 241, 242)=
; }

.gwd-red-after-visit[data-v-07d1070f]:hover { color: rgb(224, 48, 36) !impo=
rtant; }

.gwd-button[data-v-07d1070f]:hover { filter: brightness(1.1); }

.gwd-button[data-v-07d1070f] { padding-top: 1px; padding-bottom: 1px; }

.gwd-button[data-v-07d1070f]:active { filter: brightness(0.9); }

.gwd-fadeout-5s[data-v-07d1070f] { opacity: 0; transition: opacity 5s; }

.gwd-scrollbar[data-v-07d1070f]::-webkit-scrollbar { width: 6px; border-rad=
ius: 17px; }

.gwd-scrollbar[data-v-07d1070f]::-webkit-scrollbar-thumb { border-radius: 1=
7px; background: rgb(153, 153, 153); }

#gwdang_main[data-v-07d1070f], .gwdang-main[data-v-07d1070f], .bjgext-detai=
l[data-v-07d1070f] { font-size: 12px; }

#gwdang_main button[data-v-07d1070f], .gwdang-main button[data-v-07d1070f],=
 .bjgext-detail button[data-v-07d1070f] { text-align: center; }

.gwd-width-100[data-v-07d1070f] { width: 100%; }

.gwd-overlay[data-v-07d1070f] { font-family: "Microsoft YaHei", Arial, SimS=
un, serif; font-size: 0px; position: fixed; inset: 0px; background: rgba(0,=
 0, 0, 0.35); z-index: 999999999; }

.gwd-font-pfm[data-v-07d1070f] { font-family: PingFangSC-Medium; font-weigh=
t: normal !important; }

@font-face { font-family: PingFangSC-Medium; src: local("PingFangSC-Medium"=
); }

.gwd-font-pfm[data-v-07d1070f] { font-weight: bold; }

#gwd_minibar svg[data-v-07d1070f], .gwdang-main svg[data-v-07d1070f], #bjge=
xt_mb_bg svg[data-v-07d1070f], #bjgext_mainbar svg[data-v-07d1070f] { fill:=
 transparent; }

.gwd-common-font[data-v-07d1070f] { font-family: "PingFang SC", "Microsoft =
YaHei", \5fae \8f6f \96c5 \9ed1 , "Hiragino Sans GB", "WenQuanYi Micro Hei"=
; }

.gwd-taobao[data-v-07d1070f] { margin-top: 20px; }

.gwd-taobao span[data-v-07d1070f] { color: rgb(255, 68, 0); }

.gwd-jd[data-v-07d1070f] { margin-top: 20px; }

.gwd-jd span[data-v-07d1070f] { color: rgb(226, 35, 26); }

a[data-v-07d1070f] { white-space: nowrap; position: relative; height: 24px;=
 font-family: "Microsoft YaHei"; }

a[data-v-07d1070f]:hover { text-decoration: none; cursor: pointer; }

a:hover .gwd-tooltip[data-v-07d1070f] { display: block; }

.gwd-coupon[data-v-07d1070f] { height: 24px; box-sizing: border-box; min-wi=
dth: 106px; }

.gwd-coupon[data-v-07d1070f] { background-size: contain; padding-left: 8px;=
 padding-right: 8px; }

.gwd-coupon[data-v-07d1070f]::before, .gwd-coupon[data-v-07d1070f]::after {=
 content: ""; position: absolute; top: 0px; bottom: 0px; width: 9px; backgr=
ound-size: contain; }

.gwd-coupon[data-v-07d1070f]::before { left: 0px; }

.gwd-coupon[data-v-07d1070f]::after { right: 0px; transform: rotate(180deg)=
; }

.gwd-coupon.gwd-taobao[data-v-07d1070f] { background-image: url("data:image=
/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAA0CAYAAAAjfRLqAAAAAXNSR0IArs4c6QA=
AAU5JREFUeF7tlNENgDAQhdrd3H+lc4cmGgX8r5YHca+eFgAtsOdaA+IJRb5AQcsDoOHvmekPTb=
Mq5ilosXwiekETrYqZClosn4he0ESrYqaCFssnohc00aqYqaDF8onoBU20KmYqaLF8InpBE62Km=
QpaLJ+IXtBEq2KmghbLJ6IXNNGqmKmgxfKJ6AVNtCpmKmixfCJ6QROtipkKWiyfiF7QRKtipoIW=
yyeiFzTRqpipoMXyiegFTbQqZiposXwiekETrYqZClosn4he0ESrYqaCFssnohc00aqYqaDF8on=
oBU20KmYqaLF8InpBE62KmQpaLJ+IXtBEq2KmghbLJ6IXNNGqmKmgxfKJ6AVNtCpmKmixfCJ6QR=
OtipkKWiyfiF7QRKtipoL+m/yZv9341fvuuVYLvTp5H3tygYJ+ct3zd/eTOdxuH57rWAt8coEbb=
yjDgopRg1YAAAAASUVORK5CYII=3D"); }

.gwd-coupon.gwd-taobao[data-v-07d1070f]::before, .gwd-coupon.gwd-taobao[dat=
a-v-07d1070f]::after { background-repeat: no-repeat; background-image: url(=
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAA0CAYAAACHO2h8AAAAAXNS=
R0IArs4c6QAAAZJJREFUSEvtlz9OAkEUh79NsNJiOy038QDuEUggxM6INWCrDRRSwwE0UtqtiR7=
A3mKPwBH2CF7AZM2bAeJkIeyb3U004TU0w5f3Z37vNxtQUwTCybvkVXkNgT79E3MzumjDQwJnkb=
rSYmknITymcB6rYAZkGt4m4og5OSMkM4EpYgNawUJaZEDIewan5Ut0QKurIKm0TUaSWcnYBloCc=
SVQ3mFMwMKUJKUpwk6tQ0KANMTWMn2F3kiBAXf8xyEMZ9CfqCBy2AV9fIHAPMIF1SYR5ch/J16U=
iPTn7lld3Bok0ogIuDK3ejiHwUwFcyXSNeNPEeG+ZZjfkrH7Zr8sVRugGa3ll0R8I1rzU7/ZRS0=
jERlXTO8WpknJ7thjxfGLYJ9S1S4qgmTkNxMvmTQkkdq0drCjbResGYmsfO0v2pFsSKWTFLUmdj=
SYqwT7H+xI9rTHa237PqrJjuzL4X4B12NVww92tL9d9maLHYmXtRAPir2fx85HTS121B9bsSre1=
+uiG7Kj/T3deaLe77UKiWz++gOA98aFVwFZGwAAAABJRU5ErkJggg=3D=3D"); }

.gwd-coupon.gwd-taobao[data-v-07d1070f]:hover { background-image: url("data=
:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAA0CAYAAAAjfRLqAAAAAXNSR0IAr=
s4c6QAAAVNJREFUeF7tlMENgzAUxZLd2H+NXrvB7w6RQMU290D8bLFXTwuAFthzrQHxhCJfoKDl=
AdDw93w//aFpVsU8BS2WT0QvaKJVMVNBi+UT0QuaaFXMVNBi+UT0giZaFTMVtFg+Eb2giVbFTAU=
tlk9EL2iiVTFTQYvlE9ELmmhVzFTQYvlE9IImWhUzFbRYPhG9oIlWxUwFLZZPRC9oolUxU0GL5R=
PRC5poVcxU0GL5RPSCJloVMxW0WD4RvaCJVsVMBS2WT0QvaKJVMVNBi+UT0QuaaFXMVNBi+UT0g=
iZaFTMVtFg+Eb2giVbFTAUtlk9EL2iiVTFTQYvlE9ELmmhVzFTQYvlE9IImWhUzFbRYPhG9oIlW=
xUwFLZZPRC9oolUxU0GL5RPRC5poVcxU0G+TP/O2Gz963z3XaqFHJ+9jdy5Q0Heue/7ufjKH2+3=
Dcx1rgb9c4AdcEryACPINxAAAAABJRU5ErkJggg=3D=3D"); }

.gwd-coupon.gwd-taobao[data-v-07d1070f]:hover::before, .gwd-coupon.gwd-taob=
ao[data-v-07d1070f]:hover::after { background-image: url("data:image/png;ba=
se64,iVBORw0KGgoAAAANSUhEUgAAABIAAAA0CAYAAACHO2h8AAAAAXNSR0IArs4c6QAAAYtJRE=
FUSEvtl79Kw2AUxX+BuCiULroVstfBVadIOwgd3NqxOOii4GAfwDoLdqpjcVdfwKF7HZydHH0JI=
XJvk+pHWujNH6nQC9mSk/Pde849iUdB5QlO1CTKi1cS0ONnZmIuo/oBnA9gp2YGTB9tqwL9Jwh2=
TWAKpA0PCdjgmoguwkzADDUDisGq+HwAVYYT0xEdoFgKYyBURsJsyZoH9Abs5QKKGlziMWC7Bve=
TJblMb5tOrcEIj0CPJCUSOOxkAEosslmBTg9apyaQH0YJ0MM7iI4ylCvIwixiHPlv4mmLSH9Obs=
yHS4DEGgEex6rq9hW0eyYw1yJNHf9YGz58NTV+sbJvX0wboByvRUcEfCFey+Z+3UW+WuRODRt24=
GJgb7aTImJY0ZNx3bo6krG3zkzTSmiXZJHCvLaOo3kCK8cica6tYhzJhjQmSXrVZtiO/yGOjJ8y=
fxJHXX1L1qklFKN1HC10v8aRZJnPSOOovg/951WIIzGqXMZMS3utsBQxdcW9udj/tRxEZo9+AyV=
qv4MZSS3ZAAAAAElFTkSuQmCC"); }

.gwd-coupon.gwd-jd[data-v-07d1070f] { background-image: url("data:image/png=
;base64,iVBORw0KGgoAAAANSUhEUgAAAKoAAAAsCAYAAAD1nyNHAAAAAXNSR0IArs4c6QAAAR1=
JREFUeF7tnbERgFAMhcz+2+k0VnGF33kcWFvwAmfrXD1dAHCBee9nAZwhyi9QqPIAKPNnd/uiUm=
yJOQtVLJ80vVBJtsSshSqWT5peqCRbYtZCFcsnTS9Uki0xa6GK5ZOmFyrJlpi1UMXySdMLlWRLz=
FqoYvmk6YVKsiVmLVSxfNL0QiXZErMWqlg+aXqhkmyJWQtVLJ80vVBJtsSshSqWT5peqCRbYtZC=
FcsnTS9Uki0xa6GK5ZOmFyrJlpi1UMXySdMLlWRLzFqoYvmk6YVKsiVmLVSxfNL0QiXZErMWqlg=
+aXqhkmyJWQtVLJ80vVBJtsSshSqWT5peqCRbYtZCFcsnTe/3PSRbYtZC/V9+v086cDAH7/RKF/=
j9Ah900KcI8oZhhwAAAABJRU5ErkJggg=3D=3D"); }

.gwd-coupon.gwd-jd[data-v-07d1070f]::before, .gwd-coupon.gwd-jd[data-v-07d1=
070f]::after { background-image: url("data:image/png;base64,iVBORw0KGgoAAAA=
NSUhEUgAAABIAAAAsCAYAAABovuiKAAAAAXNSR0IArs4c6QAAAdVJREFUSEvNVlFO20AQfbOzay=
EhUUepgkIicFBKCmoljpAb0CNwA7gBuUG4AUfhCCvb6jdH4DPFldhqXCWya/Exi5G6n5b9/ObNm=
zdL6OmQ4LwUZXgv3scAudMZaH8/ilyHEX8egsdjNVgNtMnzFUCZAa5AlPJoBD4cqcBqoO3Z+HJp=
GI+UOLjFIh6o2cHk+7d4oMr7y8DWwzkkXyMYbYrimog+UcAKQCr6iE6a0+matF9soD0tIHs6g+n=
DR1qBm6xbjMwgrbWhJNFWhq5GiYOdzdRgO0NuvM+Y7UMAljGCt5wdvE8rts9gRnJxriqvBdSbs3=
+XP+9ew+squrSqKB8DKANCJqz45Bh8cKAvbRe1xoAnR+A0VYHIy63292ZItzhT+2dLvRu1Eem4K=
60qigeJWjGjPLTTCcxgoNKp5aNfeX5LZNbR7W/+ettBrfD/hL/PDNun6BGRgQWQsXXrEMKlxImd=
TvUatXa/c3XUajOp1X4JfTMcgphVbD7O2TH+edPZsq7tfK4u7+8lQnY+QgqDNYiyd18idiv7v4n=
aKi9vAuGe9vbgvsxVFqg1kukPIInFH3XUTifgmOlvOjvmJtIxpLs4V7f9TR+phGm83O89O5ZF87=
s/IaG3Cf8Fdl8AAAAASUVORK5CYII=3D"); background-size: cover; background-repe=
at: no-repeat; }

.gwd-coupon.gwd-jd[data-v-07d1070f]:hover { background-image: url("data:ima=
ge/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKoAAAAsCAYAAAD1nyNHAAAAAXNSR0IArs4c6=
QAAAR9JREFUeF7tnbENgFAQhbz9t9NdTGzUFX73Q8DagncQW+fo6QKAC8xzXh+AM0T5BQpVHgBl=
/rz33ReVYkvMWahi+aTphUqyJWYtVLF80vRCJdkSsxaqWD5peqGSbIlZC1UsnzS9UEm2xKyFKpZ=
Pml6oJFti1kIVyydNL1SSLTFroYrlk6YXKsmWmLVQxfJJ0wuVZEvMWqhi+aTphUqyJWYtVLF80v=
RCJdkSsxaqWD5peqGSbIlZC1UsnzS9UEm2xKyFKpZPml6oJFti1kIVyydNL1SSLTFroYrlk6YXK=
smWmLVQxfJJ0wuVZEvMWqhi+aTphUqyJWYtVLF80vRCJdkSsxaqWD5per/vIdkSsxbqfvn9PmnB=
wSy80ytdYPsFfqOApDYolPr+AAAAAElFTkSuQmCC"); }

.gwd-coupon.gwd-jd[data-v-07d1070f]:hover::before, .gwd-coupon.gwd-jd[data-=
v-07d1070f]:hover::after { background-image: url("data:image/png;base64,iVB=
ORw0KGgoAAAANSUhEUgAAABIAAAAsCAYAAABovuiKAAAAAXNSR0IArs4c6QAAAclJREFUSEvNlt=
tNw0AQRe/MrgURChgThUeAmEcBKSEdQAl0AB2QDkIHlEIJlm3xTQl8BoyURePIkY3Fx6yDxPxFc=
q5m75x5EDYUJDqfWe666v2NkBmdgHs9r+RaGXEYwgwO1GKl0CJNZwDFDNyAKORoHyaKVGKlUBWL=
JJ+ywQtZCxuP/YXqFQyur/yFiiSZOGMTWIvAJ6NFlt0R0R45zAD4e1QHknrbsKOR6lnycaP8dnQ=
C2gRHWoPraTcy4n4fwhAFQbenlW+1FtIqWrE1kIskiY2xzw6Yik/ilyYaZLskCQtj38GM4PJCo7=
OqWj0qFLTGN4S+8tfHpVvOfFgqhYosf3GgGHCx/DbHR+CdHf3T1mQzwwwG4N2+SqRFttaXX4G04=
3M1P5VYe9RGEUy07/e0IsueZdQKjKXZw6Hap0b5P9L0gYjnncne2KiVfmNj37xbRAQAxMYGc+fc=
RMaJORyqDG+vbFlFvmOkIlvKTmEIYlZl83dk+/DzK9nluj4/g1ROE6sjQnY+XAjGHERx5yNivbL=
/zagt0vzeEZ5oawv27FRj0Wr4S/c7UAjgtlP3148IH6PbR8TlhRfVLSGVKT8+3uyd3SWT6r/fRd=
q0N2b1Td4AAAAASUVORK5CYII=3D"); }

.gwd-redpack[data-v-07d1070f] { padding-right: 5px; padding-left: 8px; back=
ground: white; }

.gwd-redpack.gwd-taobao[data-v-07d1070f] { border: 1px solid rgb(255, 68, 0=
); }

.gwd-redpack.gwd-taobao[data-v-07d1070f]:hover { background: rgb(255, 240, =
231); }

.gwd-redpack.gwd-jd[data-v-07d1070f] { border: 1px solid rgb(249, 210, 211)=
; }

.gwd-redpack.gwd-jd[data-v-07d1070f]:hover { background: rgb(255, 240, 231)=
; }

.gwd-tooltip[data-v-07d1070f] { position: absolute; top: -30px; left: 50%; =
transform: translateX(-50%); width: 60px; height: 22px; line-height: 22px; =
text-align: center; z-index: 1; color: rgb(60, 60, 60); box-shadow: rgba(0,=
 0, 0, 0.15) 0px 2px 8px; display: none; background: white; border-radius: =
2px; }

.gwd-tooltip span[data-v-07d1070f] { color: rgb(60, 60, 60); }

.gwd-tooltip[data-v-07d1070f]::after { content: " "; position: absolute; bo=
ttom: -10px; left: 50%; margin-left: -5px; border-width: 5px; border-style:=
 solid; border-color: transparent transparent white; transform: rotate(180d=
eg); }
------MultipartBoundary--hilTfECGzfblg3Rc6bmhAOa4CMWAow6sJwGYp9QSnX----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-306094f0-ac98-4937-be23-8d4bb25bf12e@mhtml.blink

@charset "windows-1252";

.gwd-row { display: flex; flex-direction: row; }

.gwd-inline-row { display: inline-flex; flex-direction: row; }

.gwd-column { display: flex; flex-direction: column; }

.gwd-inline-column { display: inline-flex; flex-direction: column; }

.gwd-align { align-content: center; align-items: center; }

.gwd-jcc { justify-content: center; }

.gwd-jic { justify-items: center; }

.gwd-button { outline: none; border: none; }

.bjg-bar-button { font-size: 0px; }

.bjg-hover-bg { background: rgb(255, 251, 239); }

.bjg-bar-button:hover { background: rgb(255, 251, 239); cursor: pointer; }

.bjg-bar-button:hover .bjg-window { display: block; }

.mainbar-fold .bjg-bar-button, .mainbar-fold #top_coupon_btn, .mainbar-fold=
 .rinfo-btn, .mainbar-fold .gwd-bottom-tmall { display: none !important; }

.gwd-font12 { font-size: 12px; }

.gwd-font14 { font-size: 14px; }

.gwd-red { color: rgb(255, 53, 50); }

.gwd-red-bg { background: rgb(255, 53, 50); }

.gwd-hui333 { color: rgb(51, 51, 51); }

.gwd-hui999 { color: rgb(153, 153, 153); }

.gwd-font10 { font-size: 12px; transform: scale(0.8333); transform-origin: =
center bottom; }

.gwd-font11 { font-size: 12px; transform: scale(0.91666); transform-origin:=
 center bottom; }

.gwd-font9 { font-size: 12px; transform: scale(0.75); transform-origin: cen=
ter bottom; }

.gwd-hoverable:hover { background: rgb(237, 241, 242); }

.right-info > * { border-left: 1px solid rgb(237, 241, 242); }

.gwd-red-after-visit:hover { color: rgb(224, 48, 36) !important; }

.gwd-button:hover { filter: brightness(1.1); }

.gwd-button { padding-top: 1px; padding-bottom: 1px; }

.gwd-button:active { filter: brightness(0.9); }

.gwd-fadeout-5s { opacity: 0; transition: opacity 5s; }

.gwd-scrollbar::-webkit-scrollbar { width: 6px; border-radius: 17px; }

.gwd-scrollbar::-webkit-scrollbar-thumb { border-radius: 17px; background: =
rgb(153, 153, 153); }

#gwdang_main, .gwdang-main, .bjgext-detail { font-size: 12px; }

#gwdang_main button, .gwdang-main button, .bjgext-detail button { text-alig=
n: center; }

.gwd-width-100 { width: 100%; }

.gwd-overlay { font-family: "Microsoft YaHei", Arial, SimSun, serif; font-s=
ize: 0px; position: fixed; inset: 0px; background: rgba(0, 0, 0, 0.35); z-i=
ndex: 999999999; }

.gwd-font-pfm { font-family: PingFangSC-Medium; font-weight: normal !import=
ant; }

@font-face { font-family: PingFangSC-Medium; src: local("PingFangSC-Medium"=
); }

.gwd-font-pfm { font-weight: bold; }

#gwd_minibar svg, .gwdang-main svg, #bjgext_mb_bg svg, #bjgext_mainbar svg =
{ fill: transparent; }

.gwd-common-font { font-family: "PingFang SC", "Microsoft YaHei", \5fae \8f=
6f \96c5 \9ed1 , "Hiragino Sans GB", "WenQuanYi Micro Hei"; }
------MultipartBoundary--hilTfECGzfblg3Rc6bmhAOa4CMWAow6sJwGYp9QSnX------
